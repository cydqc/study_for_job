# 索引

MySQL官方对索引的定义为：索引（Index）是帮助MySQL高效获取数据的数据结构。

http://blog.codinglabs.org/articles/theory-of-mysql-index.html

底层是B+树。



innodb中的索引：

<u>**主键索引：key是主键，data是保存了完整的数据记录。其他索引中data是主键值。**</u>

**<u>唯一索引：数据列只包含各不相同的值，在为这个数据列创建索引的时候，就可以用关键字UNIQUE把它定义为一个唯一索引。</u>**

**<u>普通索引：运行重复的值</u>**。



## 覆盖索引

假设k是主键，k是普通索引。如果执行的语句是 select ID from T where k between 3 and 5，<u>**这时只需要查 ID 的值，而 ID 的值已经在 k 索引树上了，因此可以直接提供查询结果，不需要回表**</u>。也就是说，在这个查询里面，索引 k 已经“覆盖了”我们的查询需求，我们称为覆盖索引。由于**<u>覆盖索引可以减少树的搜索次数，显著提升查询性能</u>**，所以使用覆盖索引是一个常用的性能优化手段。

如果查询条件使用的是普通索引（或是联合索引的最左原则字段），查询结果是联合索引的字段或是主键，不用回表操作，直接返回结果，减少IO磁盘读写读取正行数据。



## 最左前缀原则

联合索引的最左 N 个字段，也可以是字符串索引的最左 M 个字符。



## 联合索引

根据创建联合索引的顺序，以最左原则进行where检索，<u>**比如（age，name）以age=1 或 age= 1 and name=‘张三’可以使用索引，单以name=‘张三’ 不会使用索引**</u>，考虑到存储空间的问题，还请根据业务需求，将查找频繁的数据进行靠左创建索引。



## 索引下推

MySQL 5.6 引入的索引下推优化（index condition pushdown)， <u>**可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数**</u>。

假设联合索引（name,age）。    对于 name like '张%' and age >10 检索，MySQL5.6版本之前只会利用张进行检索（最左前缀原则），再对匹配的数据进行回表查询。5.6版本后，会先过滤掉age<=10的数据，再进行回表查询，减少回表率，提升检索速度。



## 唯一索引和普通索引如何选择

<u>**其实，这两类索引在查询能力上是没差别的，主要考虑的是对更新性能的影响。建议尽量选择普通索引。**</u>

### 查询过程

假设，执行查询的语句是 select id from T where k=5。这个查询语句在索引树上查找的过程，先是通过 B+ 树从树根开始，按层搜索到叶子节点，也就是图中右下角的这个数据页，然后可以认为数据页内部通过二分法来定位记录。对于普通索引来说，查找到满足条件的第一个记录 (5,500) 后，需要查找下一个记录，直到碰到第一个不满足 k=5 条件的记录。对于唯一索引来说，由于索引定义了唯一性，查找到第一个满足条件的记录后，就会停止继续检索。

### 更新过程

为了说明普通索引和唯一索引对更新语句性能的影响这个问题，需要先介绍一下 change buffer。

当需要更新一个数据页时，如果数据页在内存中就直接更新，而如果这个数据页还没有在内存中的话，在不影响数据一致性的前提下，InnoDB 会将这些更新操作缓存在 change buffer 中，这样就不需要从磁盘中读入这个数据页了。在下次查询需要访问这个数据页的时候，将数据页读入内存，然后执行 change buffer 中与这个页有关的操作。通过这种方式就能保证这个数据逻辑的正确性。

需要说明的是，虽然名字叫作 change buffer，实际上它是可以持久化的数据。也就是说，change buffer 在内存中有拷贝，也会被写入到磁盘上。

将 change buffer 中的操作应用到原数据页，得到最新结果的过程称为 merge。除了访问这个数据页会触发 merge 外，系统有后台线程会定期 merge。在数据库正常关闭（shutdown）的过程中，也会执行 merge 操作。

显然，如果能够将更新操作先记录在 change buffer，减少读磁盘，语句的执行速度会得到明显的提升。而且，数据读入内存是需要占用 buffer pool 的，所以这种方式还能够避免占用内存，提高内存利用率。

**那么，什么条件下可以使用 change buffer 呢？**

对于唯一索引来说，所有的更新操作都要先判断这个操作是否违反唯一性约束。比如，要插入 (4,400) 这个记录，就要先判断现在表中是否已经存在 k=4 的记录，而这必须要将数据页读入内存才能判断。如果都已经读入到内存了，那直接更新内存会更快，就没必要使用 change buffer 了。

**<u>因此，唯一索引的更新就不能使用 change buffer，实际上也只有普通索引可以使用。</u>**

change buffer 用的是 buffer pool 里的内存，因此不能无限增大。change buffer 的大小，可以通过参数 innodb_change_buffer_max_size 来动态设置。这个参数设置为 50 的时候，表示 change buffer 的大小最多只能占用 buffer pool 的 50%。

再一起来看看如果要在这张表中插入一个新记录 (4,400) 的话，InnoDB 的处理流程是怎样的。

第一种情况是，这个记录要更新的<u>**目标页在内存中**</u>。这时，InnoDB 的处理流程如下：

- 对于唯一索引来说，找到 3 和 5 之间的位置，判断到没有冲突，插入这个值，语句执行结束；
- 对于普通索引来说，找到 3 和 5 之间的位置，插入这个值，语句执行结束。

这样看来，普通索引和唯一索引对更新语句性能影响的差别，只是一个判断，只会耗费微小的 CPU 时间。但，这不是我们关注的重点。

第二种情况是，这个记录要更新的**<u>目标页不在内存中。</u>**这时，InnoDB 的处理流程如下：

- **<u>对于唯一索引来说，需要将数据页读入内存，判断到没有冲突，插入这个值，语句执行结束</u>**；
- 对于普通索引来说，则是将更新记录在 change buffer，语句执行就结束了。

将数据从磁盘读入内存涉及随机 IO 的访问，是数据库里面成本最高的操作之一。change buffer 因为减少了随机磁盘访问，所以对更新性能的提升是会很明显的。

**<u>所以使用 change buffer 对更新过程可以起到加速作用， change buffer 只限于用在普通索引的场景下，而不适用于唯一索引。</u>**