# MySQL为什么有时候会选错索引？

对于一张表：

```sql
CREATE TABLE `t` (
    `id` int(11) NOT NULL,
    `a` int(11) DEFAULT NULL,
    `b` int(11) DEFAULT NULL,
    PRIMARY KEY (`id`),
    KEY `a` (`a`),
    KEY `b` (`b`)
) ENGINE=InnoDB；
```

我们往表 t 中插入 10 万行记录，取值按整数递增，即：(1,1,1)，(2,2,2)，(3,3,3) 直到 (100000,100000,100000)。

我们执行 select * from t where a between 10000 and 20000; 结果如下:

![image](https://github.com/cydqc/study_for_job/blob/main/mysql/images/2cfce769551c6eac9bfbee0563d48fe3.png)

这条查询语句的执行也确实符合预期，key 这个字段值是’a’，表示优化器选择了索引 a。



但如果我们执行如下这个操作：

<img src="https://github.com/cydqc/study_for_job/blob/main/mysql/%E6%9D%82%E6%8A%80/images/1e5ba1c2934d3b2c0d96b210a27e1a1e.png" alt="img" style="zoom:80%;" />

session A 就是开启了一个事务。随后，session B 把数据都删除后，又调用了 idata 这个存储过程，插入了 10 万行数据。为了说明优化器选择的结果是否正确，增加了一个对照，即：使用 force index(a) 来让优化器强制使用索引 a。

```sql
select * from t where a between 10000 and 20000; /*Q1*/
select * from t force index(a) where a between 10000 and 20000;/*Q2*/
```

Q1 扫描了 10 万行，显然是走了全表扫描，执行时间是 40 毫秒。Q2 扫描了 10001 行，执行了 21 毫秒。也就是说，我们在没有使用 force index 的时候，MySQL 用错了索引，导致了更长的执行时间。



<u>**选择索引是优化器的工作。而优化器选择索引的目的，是找到一个最优的执行方案，并用最小的代价去执行语句**。</u>在数据库里面，扫描行数是影响执行代价的因素之一。扫描的行数越少，意味着访问磁盘数据的次数越少，消耗的 CPU 资源越少。当然，**<u>扫描行数并不是唯一的判断标准，优化器还会结合是否使用临时表、是否排序等因素进行综合判断。</u>**



那么，问题就是：扫描行数是怎么判断的？MySQL 在真正开始执行语句之前，并不能精确地知道满足这个条件的记录有多少条，而只能根据统计信息（基数）来估算记录数。**<u>一个索引上不同的值的个数，我们称之为“基数”（cardinality）。也就是说，这个基数越大，索引的区分度越好。</u>**



那么，MySQL 是怎样得到索引的基数的呢？为了减少代价不会全部统计，采样统计的时候，InnoDB 默认会选择 N 个数据页，统计这些页面上的不同值，得到一个平均值，然后乘以这个索引的页面数，就得到了这个索引的基数。其实索引统计只是一个输入，对于一个具体的语句来说，优化器还要判断，执行这个语句本身要扫描多少行。如下是扫描行数：其中，Q1 的结果还是符合预期的，rows 的值是 104620；但是 Q2 的 rows 值是 37116（按理是10000左右），偏差就大了。

![img](https://github.com/cydqc/study_for_job/blob/main/mysql/%E6%9D%82%E6%8A%80/images/e2bc5f120858391d4accff05573e1289.png)

到这里，可能你的第一个疑问不是为什么不准，而是优化器为什么放着扫描 37000 行的执行计划不用，却选择了扫描行数是 100000 的执行计划呢？这是因为，**<u>如果使用索引 a，每次从索引 a 上拿到一个值，都要回到主键索引上查出整行数据，这个代价优化器也要算进去的。而如果选择扫描 10 万行，是直接在主键索引上扫描的，没有额外的代价。</u>**优化器会估算这两个选择的代价，从结果看来，优化器认为直接扫描主键索引更快。当然，从执行时间看来，这个选择并不是最优的。所以冤有头债有主，MySQL 选错索引，这件事儿还得归咎到没能准确地判断出扫描行数。<font color=red>至于原因就是mysql的标记删除。</font>并不从索引和数据文件中真正的删除。由于session A开启了一致性读,目的为了保证session A的可重复读,insert只能另起炉灶,不能占用delete的空间。所以出现的情况就是delete虽然删除了,但是未释放空间,insert又增加了空间。

既然是统计信息不对，那就修正。**<u>analyze table t 命令，可以用来重新统计索引信息。</u>**所以在实践中，如果你发现 explain 的结果预估的 rows 值跟实际情况差距比较大，可以采用这个方法来处理。



再比如下面这个例子：

```sql
select * from t where (a between 1 and 1000) and (b between 50000 and 100000) order by b limit 1;
```

如果使用索引 a 进行查询，那么就是扫描索引 a 的前 1000 个值，然后取到对应的 id，再到主键索引上去查出每一行，然后根据字段 b 来过滤。显然这样需要扫描 1000 行。如果使用索引 b 进行查询，那么就是扫描索引 b 的最后 50001 个值，与上面的执行过程相同，也是需要回到主键索引上取值再判断，所以需要扫描 50001 行。所以你一定会想，如果使用索引 a 的话，执行速度明显会快很多。

实际如下，优化器选择了索引 b。

![img](https://github.com/cydqc/study_for_job/blob/main/mysql/%E6%9D%82%E6%8A%80/images/483bcb1ef3bb902844e80d9cbdd73ab8.png)

**<u>之所以这样是因为优化器认为使用索引 b 可以避免排序（b 本身是索引，已经是有序的了，如果选择索引 b 的话，不需要再做排序，只需要遍历）</u>**，所以即使扫描行数多，也判定为代价更小。



为了避免选错索引有如下方法：

**<u>一种方法是，采用 force index 强行选择一个索引。</u>**但使用 force index 主要的问题是变更的及时性。因为选错索引的情况还是比较少出现的，所以开发的时候通常不会先写上 force index。而是等到线上出现问题的时候，你才会再去修改 SQL 语句、加上 force index。但是修改之后还要测试和发布，对于生产系统来说，这个过程不够敏捷。所以，数据库的问题最好还是在数据库内部来解决。

**<u>第二种方法就是，我们可以考虑修改语句，引导 MySQL 使用我们期望的索引。</u>**

比如对于第二个例子，将语句改成如下的：

```sql
select * from t where (a between 1 and 1000) and (b between 50000 and 100000) order by b,a limit 1;
或者
select * from (select * from t where (a between 1 and 1000) and (b between 50000 and 100000) order by b limit 100)alias limit 1;
```

**<u>第三种方法是，在有些场景下，我们可以新建一个更合适的索引，来提供给优化器做选择，或删掉误用的索引。</u>**
