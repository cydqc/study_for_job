# Mysql标记删除

在 InnoDB 中，你的 delete 操作，并不会真的把数据删除，mysql 实际上只是给删除的数据打了个标记，标记为删除，因此你使用 delete 删除表中的数据，表文件在磁盘上所占空间不会变小，我们这里暂且称之为<u>**假删除**</u>。



这些被删除的记录行，只是被标记删除，是可以被复用的，下次有符合条件的记录是可以直接插入到这个被标记的位置的。

比如我们在 id 为 300-600 之间的记录中删除一条 id=500 的记录，这条记录就会被标记为删除，等下一次如果有一条 id=400 的记录要插入进来，那么就可以复用 id=500 被标记删除的位置，这种情况叫<u>**行记录复用**</u>。

还有一种情况是<u>**数据页复用**</u>，就是指整个数据页都被标记删除了，于是这整个数据页都可以被复用了，和行记录复用不同的是，数据页复用对要插入的数据几乎没有条件限制。

还以上面那个插入为例，假如要插入的记录是 id=1000，那么就不能复用 id=500 这个位置了，但如果有一整个数据页可复用的话，那么无论 id 值为多少都可以被复用在这个页上。



因为mysql 在底层是以数据页为单位来存储和读取数据的，每次向磁盘读一次数据就是读一个数据页，然而每访问一个数据页就对应一次磁盘 IO 操作，磁盘 IO 相对内存访问速度是相当慢的。如果一个表上存在大量的数据空洞，原本只需一个数据页就保存的数据，由于被很多空洞占用了空间，不得不需要增加其他的数据页来保存数据，相应的，mysql 在查询相同数据的时候，就不得不增加磁盘 IO 操作，从而影响查询速度。

其实不仅仅是删除操作会造成数据空洞，插入和更新同样也会造成空洞。因为innodb底层是B+树，插入和更新会导致节点分裂从而出现空洞。

我们可以通过以下操作来重建表以解决数据空洞问题。

```sql
alter table t engine=InnoDB 方法一（推荐）

optimize table t  方法二（其实不是重建表，只是对表的索引信息做重新统计，没有修改数据）
```

简单描述一下引入了 Online DDL 之后，重建表的流程：

1. 建立一个临时文件，扫描表 A 主键的所有数据页；
2. 用数据页中表 A 的记录生成 B+ 树，存储到临时文件中；
3. 生成临时文件的过程中，将所有对 A 的操作记录在一个日志文件（row log）中，对应的是图中 state2 的状态；
4. 临时文件生成后，将日志文件中的操作应用到临时文件，得到一个逻辑数据上与表 A 相同的数据文件，对应的就是图中 state3 的状态；
5. 用临时文件替换表 A 的数据文件。

<img src="https://github.com/cydqc/study_for_job/blob/main/mysql/%E6%9D%82%E6%8A%80/images/2d1cfbbeb013b851a56390d38b5321f0.png" alt="img" style="zoom:60%;" />

上图的流程中，alter 语句在启动的时候需要获取 **<u>MDL 写锁</u>**，但是这个写锁在真正拷贝数据之前就退化成读锁了。为什么要退化呢？为了实现 Online，MDL 读锁不会阻塞增删改操作。那为什么不干脆直接解锁呢？为了保护自己，禁止其他线程对这个表同时做 DDL（**<u>读写锁互斥</u>**）。而对于一个大表来说，Online DDL 最耗时的过程就是拷贝数据到临时表的过程，这个步骤的执行期间可以接受增删改操作。所以，相对于整个 DDL 过程来说，锁的时间非常短。对业务来说，就可以认为是 Online 的。
